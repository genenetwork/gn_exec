defmodule GnExec.Cmd do

  @doc ~S"""
  Execute a command  and return its state and its stdout/stderr. Within loop would be possible to dipatch
  messages to some handler for monitoring the job activity (attach to some GenEnvent)

      iex> GnExec.Cmd.exec("ls")
      {0, ['LICENSE\nREADME.md\n_build\nconfig\ndoc\nlib\nmix.exs\ntest\n'], nil}

  """
  def exec(cmd, job, output_callback, transfer_callback) do
    # TODO in case of exception the directory is not removed and task can not start
    #      make it more robust
    command = apply(cmd, :script, job.args) # calling the script function dynamically
    token_path = Path.absname(job.token) # create the directory and run the script from there
    File.mkdir!(token_path) # The directory should not exist, if it exists maybe another task is running the same job
    port=Port.open({:spawn, command},[:stream, :exit_status, :use_stdio, :stderr_to_stdout, {:cd, token_path}])
    # TODO: maybe introduce callback to set up the status for the job {progress: 0}
    when_its_over = loop(port, [],0, output_callback)
    # transfer files generated by the scripts and saved in the working directory
    # POST to token etc.... all files
    # consider to post also the checksum and verify that file is correct
    # Remove the local
    transfer_callback.(job, token_path)
    File.rm_rf!(token_path)
    when_its_over
  end

  @doc ~S"""
  Timeout could be used in the future to check is the process is still alive or not

  """
  defp loop(port, cache, timeout, output) do
    receive do
      {^port, {:data, data}} ->
        output.(data)
        loop(port, [data | cache], timeout, output)
      {^port, {:exit_status, exit_status}} ->
        {exit_status, Enum.reverse(cache), output}
    end
  end
end
